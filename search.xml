<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2017 第八届蓝桥杯 魔方状态</title>
      <link href="/2025/01/07/2017%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%AD%94%E6%96%B9%E7%8A%B6%E6%80%81/"/>
      <url>/2025/01/07/2017%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%AD%94%E6%96%B9%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>二阶魔方就是只有2层的魔方，只由8个小块组成。如图{p1.png}所示。</p><p>小明很淘气，他只喜欢3种颜色，所有把家里的二阶魔方重新涂了颜色，如下：</p><p>前面：橙色</p><p>右面：绿色</p><p>上面：黄色</p><p>左面：绿色</p><p>下面：橙色</p><p>后面：黄色</p><p>请你计算一下，这样的魔方被打乱后，一共有多少种不同的状态。</p><p>如果两个状态经过魔方的整体旋转后，各个面的颜色都一致，则认为是同一状态。</p><p>请提交表示状态数的整数，不要填写任何多余内容或说明文字。<br><img src="/../../img/2017%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%AD%94%E6%96%B9%E7%8A%B6%E6%80%81/1.png" alt="p1"></p><p>开始拿到这道题没什么思路，笔算算不来，模拟判重感觉太麻烦。大神说burnside引理可以做，学渣表示看不懂。。网上基本没有求解的，有的也答案不一。最后还是模拟判重这么写了。</p><p>我的答案：229878</p><p>测试：全同色魔方状态为1，正确。正常二阶魔方状态3674160，正确。</p><p>思路：其实就是空间状态搜索。模拟操作+判重。关于操作，二阶魔方只做U(顶层顺时针) R(右层顺时针) F(前层顺时针)就可以得到所有状态了。判重需要旋转整个魔方去比较。（判重小白现在只会用set）。</p><p>然后是，怎么去表示一个二阶魔方。二阶魔方8个块，一个块6面(看不见的作黑色考虑)，所以我用了char st[8][7]去表示一个魔方。块的顺序如下：<br><img src="/../../img/2017%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%AD%94%E6%96%B9%E7%8A%B6%E6%80%81/2.png" alt="p2"><br>上面的初始状态表示就是{{"oybbgb"},{"oygbbb"},{"bygbby"},{"bybbgy"},{"obbogb"},{"obgobb"},{"bbgoby"},{"bbbogy"}}</p><p>o表示橙色，b表示黑色，g表示绿色，y表示黄色。</p><p>对于一个小块，6个面的颜色定义顺序如下：<br><img src="/../../img/2017%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%AD%94%E6%96%B9%E7%8A%B6%E6%80%81/3.png" alt="p3"><br>所以，比如说，上面题目给的魔方，前面一层，左上角的橙黄绿块，表示就是oybbgb</p><p>代码(有些丑陋见谅_(:з」∠)_ )：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> st[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">st state[<span class="number">2000000</span>];</span><br><span class="line">set&lt;string&gt; all;</span><br><span class="line">st begin=&#123;&#123;<span class="string">&quot;oybbgb&quot;</span>&#125;,&#123;<span class="string">&quot;oygbbb&quot;</span>&#125;,&#123;<span class="string">&quot;bygbby&quot;</span>&#125;,&#123;<span class="string">&quot;bybbgy&quot;</span>&#125;,&#123;<span class="string">&quot;obbogb&quot;</span>&#125;,&#123;<span class="string">&quot;obgobb&quot;</span>&#125;,&#123;<span class="string">&quot;bbgoby&quot;</span>&#125;,&#123;<span class="string">&quot;bbbogy&quot;</span>&#125;&#125;; </span><br><span class="line"><span class="type">int</span> front, tail;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ucell</span><span class="params">(<span class="type">char</span> *a)</span></span>&#123;<span class="built_in">swap</span>(a[<span class="number">0</span>], a[<span class="number">2</span>]); <span class="built_in">swap</span>(a[<span class="number">2</span>], a[<span class="number">5</span>]); <span class="built_in">swap</span>(a[<span class="number">5</span>], a[<span class="number">4</span>]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rcell</span><span class="params">(<span class="type">char</span> *a)</span></span>&#123;<span class="built_in">swap</span>(a[<span class="number">1</span>], a[<span class="number">0</span>]); <span class="built_in">swap</span>(a[<span class="number">0</span>], a[<span class="number">3</span>]); <span class="built_in">swap</span>(a[<span class="number">3</span>], a[<span class="number">5</span>]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcell</span><span class="params">(<span class="type">char</span> *a)</span></span>&#123;<span class="built_in">swap</span>(a[<span class="number">2</span>], a[<span class="number">1</span>]); <span class="built_in">swap</span>(a[<span class="number">1</span>], a[<span class="number">4</span>]); <span class="built_in">swap</span>(a[<span class="number">4</span>], a[<span class="number">3</span>]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">u</span><span class="params">(st &amp;s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ucell</span>(s[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">ucell</span>(s[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">ucell</span>(s[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">ucell</span>(s[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">1</span>], s[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">2</span>], s[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">3</span>], s[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uwhole</span><span class="params">(st &amp;s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">u</span>(s);</span><br><span class="line"><span class="built_in">ucell</span>(s[<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">ucell</span>(s[<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">ucell</span>(s[<span class="number">6</span>]);</span><br><span class="line"><span class="built_in">ucell</span>(s[<span class="number">7</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">5</span>], s[<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">6</span>], s[<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">7</span>], s[<span class="number">6</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(st &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fcell</span>(s[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">fcell</span>(s[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">fcell</span>(s[<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">fcell</span>(s[<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">1</span>], s[<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">0</span>], s[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">4</span>], s[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwhole</span><span class="params">(st &amp;s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">f</span>(s);</span><br><span class="line"><span class="built_in">fcell</span>(s[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">fcell</span>(s[<span class="number">6</span>]);</span><br><span class="line"><span class="built_in">fcell</span>(s[<span class="number">7</span>]);</span><br><span class="line"><span class="built_in">fcell</span>(s[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">2</span>], s[<span class="number">6</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">3</span>], s[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">7</span>], s[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">r</span><span class="params">(st &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">rcell</span>(s[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">rcell</span>(s[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">rcell</span>(s[<span class="number">6</span>]);</span><br><span class="line"><span class="built_in">rcell</span>(s[<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">2</span>], s[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">5</span>], s[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">6</span>], s[<span class="number">5</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rwhole</span><span class="params">(st &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">r</span>(s);</span><br><span class="line"><span class="built_in">rcell</span>(s[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">rcell</span>(s[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">rcell</span>(s[<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">rcell</span>(s[<span class="number">7</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">3</span>], s[<span class="number">7</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">0</span>], s[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">swap</span>(s[<span class="number">4</span>], s[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">convert</span><span class="params">(st &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string ss;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)ss+=s[i];</span><br><span class="line"><span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_to_insert</span><span class="params">(<span class="type">int</span> tail)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">st k;</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span>*)k, (<span class="type">void</span>*)state[tail], <span class="built_in">sizeof</span>(state[tail]));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fwhole</span>(k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">uwhole</span>(k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> q=<span class="number">0</span>; q&lt;<span class="number">4</span>; q++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">rwhole</span>(k);</span><br><span class="line"><span class="keyword">if</span>(all.<span class="built_in">count</span>(<span class="built_in">convert</span>(k))==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">all.<span class="built_in">insert</span>(<span class="built_in">convert</span>(k));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">front=<span class="number">0</span>,tail=<span class="number">1</span>;</span><br><span class="line">all.<span class="built_in">insert</span>(<span class="built_in">convert</span>(begin));</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span>*)state[<span class="number">0</span>],(<span class="type">void</span>*)begin,<span class="built_in">sizeof</span>(begin));</span><br><span class="line"><span class="keyword">while</span>(front!=tail)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span>*)state[tail], (<span class="type">void</span>*)state[front], <span class="built_in">sizeof</span>(state[front]));</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">u</span>(state[tail]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">try_to_insert</span>(tail))tail++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">r</span>(state[tail]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">try_to_insert</span>(tail))tail++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">f</span>(state[tail]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">try_to_insert</span>(tail))tail++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">front++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;front&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯_JAVA组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 蓝桥杯真题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集并查集--算法竞赛专题解析（3）</title>
      <link href="/2025/01/07/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%B9%B6%E6%9F%A5%E9%9B%86--%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%93%E9%A2%98%E8%A7%A3%E6%9E%90%EF%BC%883%EF%BC%89/"/>
      <url>/2025/01/07/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%B9%B6%E6%9F%A5%E9%9B%86--%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%93%E9%A2%98%E8%A7%A3%E6%9E%90%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="0-并查集简介"><a href="#0-并查集简介" class="headerlink" title="0 并查集简介"></a>0 并查集简介</h1><p>  并查集（Disjoint Set）是一种非常精巧而实用的数据结构，它主要用于处理一些不相交集合的合并问题。经典的应用有：连通子图、最小生成树Kruskal算法[ 参考本书第10章“10.10.2 kruskal算法”。]和最近公共祖先（Least Common Ancestors, LCA）等。<br>  并查集在算法竞赛中极为常见。<br>  通常用“帮派”的例子来说明并查集的应用背景。一个城市中有n个人，他们分成不同的帮派；给出一些人的关系，例如1号、2号是朋友，1号、3号也是朋友，那么他们都属于一个帮派；在分析完所有的朋友关系之后，问有多少帮派，每人属于哪个帮派。给出的n可能是106的。<br>  读者可以先思考暴力的方法，以及复杂度。如果用并查集实现，不仅代码很简单，而且复杂度可以达到O(logn)。<br>  并查集：将编号分别为1~n的n个对象划分为不相交集合，在每个集合中，选择其中某个元素代表所在集合。在这个集合中，并查集的操作有：初始化、合并、查找。<br>  本文比较全面地介绍了并查集：<br>  （1）并查集的基本操作。<br>  （2）并查集的优化：合并和路径压缩。<br>  （3）带权并查集。<br>  并查集的基本应用是集合问题；加上权值之后，利用并查集的合并和查询优化，可以对权值所代表的具体应用进行高效的操作。</p><h1 id="1-并查集的基本操作"><a href="#1-并查集的基本操作" class="headerlink" title="1 并查集的基本操作"></a>1 并查集的基本操作</h1><p>  （1）初始化。定义数组int s[]是以结点i为元素的并查集，开始的时候，还没有处理点与点之间的朋友关系，所以每个点属于独立的集，并且以元素i的值表示它的集s[i]，例如元素1的集s[1]&#x3D;1。<br>  下面是图解，左边给出了元素与集合的值，右边画出了逻辑关系。为了便于讲解，左边区分了结点i和集s：把集的编号加上了下划线；右边用圆圈表示集，方块表示元素。<br><img src="/../../../img/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%B9%B6%E6%9F%A5%E9%9B%86--%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%93%E9%A2%98%E8%A7%A3%E6%9E%90%EF%BC%883%EF%BC%89/1.png" alt="图1"><br>  （2）合并，例如加入第一个朋友关系(1, 2)。在并查集s中，把结点1合并到结点2，也就是把结点1的集1改成结点2的集2。<br><img src="/../../../img/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%B9%B6%E6%9F%A5%E9%9B%86--%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%93%E9%A2%98%E8%A7%A3%E6%9E%90%EF%BC%883%EF%BC%89/2.png" alt="图2"><br>  （3）合并，加入第二个朋友关系(1, 3)。查找结点1的集，是2，再递归查找元素2的集是2，然后把元素2的集2合并到结点3的集3。此时，结点1、2、3都属于一个集。右图中，为简化图示，把元素2和集2画在了一起。<br><img src="/../../../img/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%B9%B6%E6%9F%A5%E9%9B%86--%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%93%E9%A2%98%E8%A7%A3%E6%9E%90%EF%BC%883%EF%BC%89/3.png" alt="图3"><br>  （4）合并，加入第三个朋友关系(2, 4)。结果如下，请读者自己分析。<br><img src="/../../../img/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%B9%B6%E6%9F%A5%E9%9B%86--%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%93%E9%A2%98%E8%A7%A3%E6%9E%90%EF%BC%883%EF%BC%89/4.png" alt="图4"><br>  （5）查找。上面步骤中已经有查找操作。查找元素的集，是一个递归的过程，直到元素的值和它的集相等，就找到了根结点的集。从上面的图中可以看到，这棵搜索树的高度，可能很大，复杂度是O(n)的，变成了一个链表，出现了树的“退化”现象。<br>  （6）统计有多少个集。如果s[i] &#x3D; i，这是一个根结点，是它所在的集的代表；统计根结点的数量，就是集的数量。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>下面以hdu 1213为例子，实现上述操作。<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1213">http://acm.hdu.edu.cn/showproblem.php?pid=1213</a><br>  有n个人一起吃饭，有些人互相认识。认识的人想坐在一起，而不想跟陌生人坐。例如A认识B，B认识C，那么A、B、C会坐在一张桌子上。<br>  给出认识的人，问需要多少张桌子。<br>  一张桌子是一个集，合并朋友关系，然后统计集的数量即可。下面的代码是并查集操作的具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1050</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] s = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initSet</span><span class="params">()</span> &#123; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">            s[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> x)</span> &#123; <span class="comment">// 查找</span></span><br><span class="line">        <span class="keyword">return</span> x == s[x] ? x : findSet(s[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="comment">// 合并</span></span><br><span class="line">        x = findSet(x);</span><br><span class="line">        y = findSet(y);</span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            s[x] = y; <span class="comment">// 把 x 合并到 y 上，y 的根成为 x 的根</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">while</span> (t-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            initSet();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                mergeSet(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 统计有多少个集合</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == i) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  复杂度：上述程序，查找find_set()、合并merge_set()的搜索深度是树的长度，复杂度都是O(n)，性能比较差。下面介绍合并和查询的优化方法，优化之后，查找和合并的复杂度都小于O(logn)。</p><h1 id="2-合并的优化"><a href="#2-合并的优化" class="headerlink" title="2 合并的优化"></a>2 合并的优化</h1><p>  合并元素x和y时，先搜到它们的根结点，然后再合并这两个根结点，即把一个根结点的集改成另一个根结点。这两个根结点的高度不同，如果把高度较小的集合并到较大的集上，能减少树的高度。下面是优化后的代码，在初始化时用height[i]定义元素i的高度，在合并时更改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1050</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] s = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] height = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initSet</span><span class="params">()</span> &#123; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">        height[i] = <span class="number">0</span>; <span class="comment">// 树的高度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="comment">// 优化合并操作</span></span><br><span class="line">    x = findSet(x);</span><br><span class="line">    y = findSet(y);</span><br><span class="line">    <span class="keyword">if</span> (height[x] == height[y]) &#123;</span><br><span class="line">        height[x] = height[x] + <span class="number">1</span>; <span class="comment">// 合并，树的高度加一</span></span><br><span class="line">        s[y] = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 把矮树并到高树上，高树的高度保持不变</span></span><br><span class="line">        <span class="keyword">if</span> (height[x] &lt; height[y]) &#123;</span><br><span class="line">            s[x] = y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s[y] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> x)</span> &#123; <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">return</span> x == s[x] ? x : findSet(s[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-查询的优化——路径压缩"><a href="#3-查询的优化——路径压缩" class="headerlink" title="3 查询的优化——路径压缩"></a>3 查询的优化——路径压缩</h1><p>  在上面的查询程序find_set()中，查询元素i所属的集，需要搜索路径找到根结点，返回的结果是根结点。这条搜索路径可能很长。如果在返回的时候，顺便把i所属的集改成根结点，那么下次再搜的时候，就能在O(1)的时间内得到结果。<br><img src="/../../../img/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%B9%B6%E6%9F%A5%E9%9B%86--%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%93%E9%A2%98%E8%A7%A3%E6%9E%90%EF%BC%883%EF%BC%89/5.png" alt="图5"><br>程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1050</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] s = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x != s[x]) &#123;</span><br><span class="line">            s[x] = findSet(s[x]); <span class="comment">// 路径压缩</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例主函数，用于演示 findSet 方法的使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化数组 s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">            s[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 示例调用 findSet 方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> findSet(x);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素 &quot;</span> + x + <span class="string">&quot; 所在集合的根是 &quot;</span> + root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   这个方法称为路径压缩，因为整个搜索路径上的元素，在递归过程中，从元素i到根结点的所有元素，它们所属的集都被改为根结点。路径压缩不仅优化了下次查询，而且也优化了合并，因为合并时也用到了查询。<br>  上面代码用递归实现，如果数据规模太大，担心爆栈，可以用下面的非递归代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1050</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] s = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initSet</span><span class="params">()</span> &#123; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">            s[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> x)</span> &#123; <span class="comment">// 查找</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="keyword">while</span> (s[r] != r) &#123;</span><br><span class="line">            r = s[r]; <span class="comment">// 找到根结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x, j;</span><br><span class="line">        <span class="keyword">while</span> (i != r) &#123;</span><br><span class="line">            j = s[i]; <span class="comment">// 用临时变量 j 记录</span></span><br><span class="line">            s[i] = r; <span class="comment">// 把路径上元素的集改为根结点</span></span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="comment">// 合并</span></span><br><span class="line">        x = findSet(x);</span><br><span class="line">        y = findSet(y);</span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            s[x] = y; <span class="comment">// 把 x 合并到 y 上，y 的根成为 x 的根</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 示例用法</span></span><br><span class="line">        initSet();</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> findSet(x);</span><br><span class="line">        System.out.println(<span class="string">&quot;根结点：&quot;</span> + root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-带权并查集"><a href="#4-带权并查集" class="headerlink" title="4 带权并查集"></a>4 带权并查集</h1><p>  前面讲解了并查集的基本应用：处理集合问题。并查集的高效，主要是利用了合并和查询的优化。在这些基本应用中，点之间只有简单的归属关系，而没有权值。如果在点之间加上权值，并查集的应用会更广泛。<br>  如果读者联想到树这种数据结构，会发现，并查集实际上是在维护若干棵树。并查集的合并和查询优化，实际上是在改变树的形状，把原来“细长”的、操作低效的大量“小树”，变成了“粗短”的、操作高效的少量“大树”。如果在原来的“小树”上，点之间有权值，那么经过并查集的优化之变成“大树”后，这些权值的操作也变得高效了。</p><h2 id="4-1-带权值的路径压缩和合并"><a href="#4-1-带权值的路径压缩和合并" class="headerlink" title="4.1 带权值的路径压缩和合并"></a>4.1 带权值的路径压缩和合并</h2><p>  定义一个权值数组d[]，结点i到父结点的权值为记为d[i]。<br>  （1）带权值的路径压缩<br>   下面的图，是加上权值之后的路径压缩。原来的权值d[]，经过压缩之后，更新为d[]’，例如d[1]’&#x3D;d[1]+d[2]+d[3]。<br>   需要注意的是，这个例子中，权值是相加的关系，比较简单；在具体的题目的中，可能有相乘、异或等等符合题意的操作。<br><img src="/../../../img/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%B9%B6%E6%9F%A5%E9%9B%86--%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%93%E9%A2%98%E8%A7%A3%E6%9E%90%EF%BC%883%EF%BC%89/6.png" alt="图6"><br>  相应地，在这个权值相加的例子中，把路径压缩的代码改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] s;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x != s[x]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> s[x]; <span class="comment">// 记录父结点</span></span><br><span class="line">            s[x] = findSet(s[x]); <span class="comment">// 路径压缩。递归最后返回的是根结点</span></span><br><span class="line">            d[x] += d[t]; <span class="comment">// 权值更新为 x 到根节点的权值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 示例初始化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxn</span> <span class="operator">=</span> <span class="number">1050</span>;</span><br><span class="line">        s = <span class="keyword">new</span> <span class="title class_">int</span>[maxn + <span class="number">1</span>];</span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">int</span>[maxn + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 示例使用</span></span><br><span class="line">        <span class="comment">// findSet(某个值);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意代码中的细节。原来的d[x]是点x到它的父结点的权值，经过路径压缩后，x直接指向根节点，d[x]也更新为x到根结点的权值。这是通过递归实现的。<br>  代码中，先用t记录x的原父结点；在递归过程中，最后返回的是根节点；最后将当前节点的权值加上原父结点的权值（注意：经过递归，此时父结点也直接指向根节点，父结点的权值也已经更新为父结点直接到根结点的权值了），就得到当前节点到根节点的权值。<br>  （2）带权值的合并<br>   在合并操作中，把点x与到点y合并，就是把x的根结点fx合并到y的根结点fy。在fx和fy之间增加权值，这个权值要符合题目的要求。</p><h2 id="4-2例题"><a href="#4-2例题" class="headerlink" title="4.2例题"></a>4.2例题</h2><p>   下面用2个经典例题讲解带权并查集，hdu 3038和poj 1182。<br>  （1）例题1：hdu 3038<br>∎问题描述<br>  给出区间[a, b]，区间之和为v。输入m组数据，每输入一组，判断此组条件是否与前面冲突，最后输出与前面冲突的数据的个数。比如先给出[1, 5]区间和为100，再给出区间[1, 2]的和为200，肯定有冲突。<br>∎题解<br>  本题是本节讲解的带权值并查集的直接应用。如果能想到可以把序列建模为并查集，就能直接套用模板了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">200010</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] s = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initSet</span><span class="params">()</span> &#123; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">            s[i] = i;</span><br><span class="line">            d[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> x)</span> &#123; <span class="comment">// 带权值的路径压缩</span></span><br><span class="line">        <span class="keyword">if</span> (x != s[x]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> s[x]; <span class="comment">// 记录父结点</span></span><br><span class="line">            s[x] = findSet(s[x]); <span class="comment">// 路径压缩。递归最后返回的是根结点</span></span><br><span class="line">            d[x] += d[t]; <span class="comment">// 权值更新为 x 到根节点的权值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSet</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> v)</span> &#123; <span class="comment">// 合并</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">roota</span> <span class="operator">=</span> findSet(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootb</span> <span class="operator">=</span> findSet(b);</span><br><span class="line">        <span class="keyword">if</span> (roota == rootb) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[a] - d[b] != v) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s[roota] = rootb; <span class="comment">// 合并</span></span><br><span class="line">            d[roota] = d[b] - d[a] + v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextInt()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            initSet();</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (m-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                a--;</span><br><span class="line">                mergeSet(a, b, v);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>∎问题描述<br>  动物王国中有三类动物A、B、C，这三类动物的食物链是：A吃B，B吃C，C吃A。<br>  现有N个动物，以1~N编号。每个动物都是A、B、C中的一种，但是我们并不知道它到底是哪一种。<br>  有人用两种说法对这N个动物所构成的食物链关系进行描述：<br>  第一种说法是”1 X Y”，表示X和Y是同类。<br>  第二种说法是”2 X Y”，表示X吃Y。<br>  此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。<br>  1） 当前的话与前面的某些真的话冲突，就是假话；<br>  2） 当前的话中X或Y比N大，就是假话；<br>  3） 当前的话表示X吃X，就是假话。<br>  你的任务是根据给定的N（1 &lt;&#x3D; N &lt;&#x3D; 50,000）和K句话（0 &lt;&#x3D; K &lt;&#x3D; 100,000），输出假话的总数。<br>∎题解<br>  这一题中的权值比较有趣，它不是上一题中相加的关系。把权值d[]记录为两个动物在食物链上的相对关系。下面用d(A-&gt;B)表示A、B的关系，d(A-&gt;B) &#x3D; 0表示同类，d(A-&gt;B) &#x3D; 1表示A吃B，d(A-&gt;B) &#x3D; 2表示A被B吃。<br>  这一题难点在权值的更新。考虑三个问题：<br>  （i）路径压缩时，如何更新权值。<br>  若d(A-&gt;B) &#x3D;1，d(B-&gt;C) &#x3D; 1，求d(A-&gt;c)。因为A吃B，B吃C，那么C应该吃A，得d(A-&gt;C)&#x3D;2；<br>  若d(A-&gt;B) &#x3D;2，d(B-&gt;C) &#x3D;2，求d(A-&gt;c)。因为B吃A，C吃B，那么A应该吃C，得d(A-&gt;C)&#x3D;1；<br>  若d(A-&gt;B) &#x3D; 0，d(B-&gt;C) &#x3D;1，求d(A-&gt;c)。因为A、B同类，B吃C，那么A应该吃C，得d(A-&gt;C)&#x3D;1；<br>  找规律知：d(A-&gt;C) &#x3D; (d(A-&gt;B) + d(B-&gt;C) ) % 3，因此关系值的更新是累加再模3。<br>  （ii）合并时，如何更新权值。本题的权值更新是取模操作，内容见下面的代码。<br>  （iii）如何判断矛盾。如果已知A与根节点的关系，B与根节点的关系，如何求A、B之间的关系？内容见下面的代码。<br>  下面是代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">50005</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] s = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];    <span class="comment">// 集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];    <span class="comment">// 0：同类；1：吃；2：被吃</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initSet</span><span class="params">()</span> &#123; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">            s[i] = i;</span><br><span class="line">            d[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findSet</span><span class="params">(<span class="type">int</span> x)</span> &#123; <span class="comment">// 带权值的路径压缩</span></span><br><span class="line">        <span class="keyword">if</span> (x != s[x]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> s[x]; <span class="comment">// 记录父结点</span></span><br><span class="line">            s[x] = findSet(s[x]); <span class="comment">// 路径压缩。递归最后返回的是根结点</span></span><br><span class="line">            d[x] = (d[x] + d[t]) % <span class="number">3</span>; <span class="comment">// 权值更新为x到根节点的权值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> relation)</span> &#123; <span class="comment">// 合并</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootx</span> <span class="operator">=</span> findSet(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rooty</span> <span class="operator">=</span> findSet(y);</span><br><span class="line">        <span class="keyword">if</span> (rootx == rooty) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((relation - <span class="number">1</span>) != ((d[x] - d[y] + <span class="number">3</span>) % <span class="number">3</span>)) &#123; <span class="comment">// 判断矛盾</span></span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s[rootx] = rooty; <span class="comment">// 合并</span></span><br><span class="line">            d[rootx] = (d[y] - d[x] + relation - <span class="number">1</span>) % <span class="number">3</span>; <span class="comment">// 更新权值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        initSet();</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">relation</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (x &gt; n || y &gt; n || (relation == <span class="number">2</span> &amp;&amp; x == y)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mergeSet(x, y, relation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯_JAVA组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯2017省赛A组第3题</title>
      <link href="/2025/01/07/%E8%93%9D%E6%A1%A5%E6%9D%AF2017%E7%9C%81%E8%B5%9BA%E7%BB%84%E7%AC%AC3%E9%A2%98/"/>
      <url>/2025/01/07/%E8%93%9D%E6%A1%A5%E6%9D%AF2017%E7%9C%81%E8%B5%9BA%E7%BB%84%E7%AC%AC3%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><pre><code>一个二阶魔方，有6个面，但是只涂了3种颜色：  </code></pre><p>  （1）前面、下面：涂橙色<br>  （2）右面、左面：涂绿色<br>  （3）上面、后面：涂黄色<br>  然后随便你打乱它，问一共有多少种不同状态。<br>  如果两个状态经过魔方的整体旋转后，各个面的颜色都一致，则认为是同一状态。</p><h1 id="2-方法尝试"><a href="#2-方法尝试" class="headerlink" title="2.方法尝试"></a>2.方法尝试</h1><p>  既然是填空题，看有没有投机取巧的办法。<br>  正常的二阶魔方，有6种颜色，每个角块都不同，共8种角块。以一个角块不动作为参考角块，其他7个角块都能任意转换方向。有7 ! 7!7!种情况。<br>  7个角块排列的时候，只有6格角块可以自由选择方向，第7个角块的方向取决于前6个（玩过魔方都知道，其他7块固定时，1个角块不能在原地转动），有$3^6$ 种情况。<br>  所有情况一共有：7 ! × $3^{6}$&#x3D; 3 , 674 , 160。<br>  正常魔方是很简单的。<br>  本题只有三种颜色，却复杂得多。倪文迪说用排列组合很难做，本教师不相信。结果浪费半天时间之后，被迫同意他的说法。<br>  为了找出到底有几种不同的角块，本教师用白纸做了一个破六面体，观察好久，终于发现：<br>  本题的二阶魔方，涂3种颜色，只有4种不同的角块，每种2个。设三种颜色是1、2、3，这4种角块是：132、312、113、322。<br>  这4种角块，有三种颜色的角块132、312，和两种颜色的角块113、322。<br>  问有几种排列？下面尝试排列一下。<br>  先看2个三色角块132，可以并排放、对角放、反对角放（互相看不见），共3种，每种有3个旋转，共3 × 3 &#x3D; 9种情况。<br>  然后再放2个三色角块312…<br>  …<br>  本教师已经晕了，做不下去了。<br>  偷看了答案，是229878，229878 &#x3D; 43 × 11 × $3^5$ × 2 ，估计不是一个简单的排列吧。<br>  据说能用Burnside引理做，哪位大神做了请告诉我，让大家一起学学。</p><h1 id="3-放弃方法"><a href="#3-放弃方法" class="headerlink" title="3.放弃方法"></a>3.放弃方法</h1><p>既然用数学方法想不通，就只能用计算机暴力求解了，基本思路是：模拟魔方的旋转，把每次新的旋转结果看成一个状态，然后用BFS搜索所有的状态，看一共有多少种。当然，还要对状态判重。<br>  不过，这是一个代码很复杂（很恶心）的模拟题，比赛的时候做，简直是浪费生命、浪费其他题得分的机会。对省赛这种得奖面大的比赛，还是放弃吧。<br>  最后是倪文迪说的话：“这道题目初看是排列组合，但由于其涂色的特殊性，不方便由组合数学解决。只能考虑终极搜索+模拟…对于这几个块形成的魔方，定义它为一种状态，我们需要做的就是模拟魔方的旋转，并判定当前状态是否与之前出现过的状态重复。然后我们建一维数组，人为规定状态表达，填入到数组中，再判重。”<br>  参考一位大神写的模拟，非常佩服（小声说一句，运行时间很长很长，不要误会死机了）：<a href="../2017%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%AD%94%E6%96%B9%E7%8A%B6%E6%80%81">大神模拟</a></p><h1 id="4-大神手算"><a href="#4-大神手算" class="headerlink" title="4.大神手算"></a>4.大神手算</h1><p>本博客发布之后，本校大神杭业晟（获得第十一届蓝桥杯全国总决赛A组一等奖）表示，他去学了一下Burnside引理，然后手算了这个题。<br>  先学这个：<a href="https://baike.baidu.com/item/%E4%BC%AF%E6%81%A9%E8%B5%9B%E5%BE%B7%E5%BC%95%E7%90%86/8939639?fromtitle=burnside%E5%BC%95%E7%90%86">Burnside引理</a><br>  下面是杭业晟的手算：“我发现立方体有24个置换群…最后再除3是因为只有1&#x2F;3是能够转的出来的”。<br><img src="/../../img/2017%E7%9C%81%E8%B5%9BA%E7%BB%84%E7%AC%AC3%E9%A2%98/1.jpeg" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯_JAVA组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 蓝桥杯真题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯2019省赛A组第1题</title>
      <link href="/2025/01/07/%E8%93%9D%E6%A1%A5%E6%9D%AF2019%E7%9C%81%E8%B5%9BA%E7%BB%84%E7%AC%AC1%E9%A2%98/"/>
      <url>/2025/01/07/%E8%93%9D%E6%A1%A5%E6%9D%AF2019%E7%9C%81%E8%B5%9BA%E7%BB%84%E7%AC%AC1%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><pre><code>小明对数位中含有2、0、1、9 的数字很感兴趣，在1 到40 中这样的数包括1、2、9、10 至32、39 和40，共28 个，他们的和是574，平方和是14362。注意，平方和是指将每个数分别平方后求和。  请问，在1 到2019 中，所有这样的数的平方和是多少？</code></pre><h1 id="2-代码演示"><a href="#2-代码演示" class="headerlink" title="2.代码演示"></a>2.代码演示</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2019</span>;i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">            <span class="keyword">if</span>(s.contains(<span class="string">&quot;2&quot;</span>) || s.contains(<span class="string">&quot;0&quot;</span>) || s.contains(<span class="string">&quot;1&quot;</span>) || s.contains(<span class="string">&quot;9&quot;</span>))</span><br><span class="line">                sum += i*i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯_JAVA组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 蓝桥杯真题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯2019省赛A组第8题</title>
      <link href="/2025/01/07/%E8%93%9D%E6%A1%A5%E6%9D%AF2019%E7%9C%81%E8%B5%9BA%E7%BB%84%E7%AC%AC8%E9%A2%98/"/>
      <url>/2025/01/07/%E8%93%9D%E6%A1%A5%E6%9D%AF2019%E7%9C%81%E8%B5%9BA%E7%BB%84%E7%AC%AC8%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>2019省赛A组第8题“修改数组” ，题目链接：<br><a href="http://oj.ecustacm.cn/problem.php?id=1459">New Online Judge</a><br><a href="https://www.dotcpp.com/oj/problem2301.html">C语言网</a></p><h1 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h1><pre><code>给定一个长度为N 的数组A = [A1, A2,…,AN]，数组中有可能有重复出现的整数。现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改A2, A3, …, AN。当修改Ai 时，小明会检查Ai 是否在A1~ Ai-1 中出现过。如果出现过，则小明会给Ai 加上1 ；如果新的Ai 仍在之前出现过，小明会持续给Ai 加1 ，直到Ai 没有在A1~Ai-1中出现过。当AN 也经过上述修改之后，显然A数组中就没有重复的整数了。现在给定初始的A 数组，请你计算出最终的A 数组。输入：第一行包含一个整数N(1&lt;=N&lt;=100000)第二行包含N个整数A1,A2,…,AN(1&lt;=Ai&lt;=1000000)输出：输出N个整数，依次是最终的A1,A2,…,AN</code></pre><h1 id="2、解题"><a href="#2、解题" class="headerlink" title="2、解题"></a>2、解题</h1><h3 id="2-1-暴力"><a href="#2-1-暴力" class="headerlink" title="2.1 暴力"></a>2.1 暴力</h3><p>先尝试暴力的方法：每读入一个新的数，就检查前面是否出现过，每一次需要检查前面所有的数。共有n nn个数，每个数检查O(n)次，所以总复杂度是O(n<sup>2</sup>)的，超时。</p><h3 id="2-2-hash"><a href="#2-2-hash" class="headerlink" title="2.2 hash"></a>2.2 hash</h3><p>容易想到一个改进的方法：用hash。定义vis[]数组，vis[i]表示数字i是否已经出现过。这样就不用检查前面所有的数了，基本上可以在O(1)的时间内定位到。<br>  然而，本题有个特殊的要求：“如果新的A<sub>i</sub>仍在之前出现过，小明会持续给A<del>i</del>加1 ，直到A<sub>i</sub>没有在A<sub>1</sub> ~ A<sub>i-1</sub>中出现过。”这导致在某些情况下，仍然需要大量的检查。以5个9为例：A[]&#x3D;{9, 9, 9, 9, 9}。<br>   第一次检查A[1]&#x3D;9，设置vis[9]&#x3D;1；<br>   第二次检查A[2]&#x3D;9，先查到vis[9]&#x3D;1，则把A[2]加1，变为a[2]&#x3D;10，设置vis[10]&#x3D;1；<br>   第三次检查A[3]&#x3D;9，先查到vis[9]&#x3D;1，则把A[3]加1得A[3]&#x3D;10；再查到vis[10]&#x3D;1，再把A[3]加1得A[3]&#x3D;11，设置vis[11]&#x3D;1；<br>   …<br>   复杂度仍然是O(n<sup>2</sup>)的。<br>   下面给出hash代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1000002</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] vis = <span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">// hash: vis[i] = 1 表示数字 i 已经存在</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// 读一个数字</span></span><br><span class="line">            <span class="keyword">while</span> (vis[a] == <span class="number">1</span>) &#123; <span class="comment">// 若 a 已经出现过，则该数加 1。若加 1 后再出现，则继续加</span></span><br><span class="line">                a++;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[a] = <span class="number">1</span>; <span class="comment">// 标记该数字</span></span><br><span class="line">            System.out.print(a + <span class="string">&quot; &quot;</span>); <span class="comment">// 打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-并查集"><a href="#2-3-并查集" class="headerlink" title="2.3 并查集"></a>2.3 并查集</h3><p>上文提到，本题用Hash方法，在特殊情况下仍然需要大量的检查。问题出在“持续给A<sub>i</sub>加1 ，直到A<sub>i</sub>没有在A<sub>1</sub> ~ A<sub>i-1</sub>中出现过”。也就是说，问题出在那些相同的数字上。当处理一个新的A[i]时，需要检查所有与它相同的数字。<br>   如果把这些相同的数字看成一个集合，就能用并查集处理。<br>   这种并查集，必须是用“路径压缩”优化的，才能加快检查速度。没有路径压缩的并查集，仍然超时。<br>   学习并查集和“路径压缩”，参考博文：<a href="../%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%B9%B6%E6%9F%A5%E9%9B%86--%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%93%E9%A2%98%E8%A7%A3%E6%9E%90%EF%BC%883%EF%BC%89/">点击此处前往</a></p><h4 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//oj.ecustacm.c User: 20180861115</span></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1000005</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> num[] = <span class="keyword">new</span> <span class="title class_">int</span>[max];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == num[x]) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num[x] = find(num[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(in.readLine());</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            String[] s = in.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000000</span>;i++) &#123;</span><br><span class="line">                num[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            k = Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line">            k = find(k);</span><br><span class="line">            num[k] = find(k+<span class="number">1</span>);</span><br><span class="line">            System.out.print(k);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">                k = Integer.parseInt(s[i]);</span><br><span class="line">                k = find(k);</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>+k);</span><br><span class="line">                num[k] = find(k+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯_JAVA组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 蓝桥杯真题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯2019省赛A组第7题</title>
      <link href="/2025/01/07/%E8%93%9D%E6%A1%A5%E6%9D%AF2019%E7%9C%81%E8%B5%9BA%E7%BB%84%E7%AC%AC7%E9%A2%98/"/>
      <url>/2025/01/07/%E8%93%9D%E6%A1%A5%E6%9D%AF2019%E7%9C%81%E8%B5%9BA%E7%BB%84%E7%AC%AC7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>2019省赛A组第7题“外卖店优先级” ，题目链接：<br><a href="http://oj.ecustacm.cn/problem.php?id=1458">蓝桥杯</a><br><a href="https://www.dotcpp.com/oj/problem2300.html">C语言网</a></p><h1 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h1><pre><code>“饱了么”外卖系统中维护着N 家外卖店，编号1~N。每家外卖店都有一个优先级，初始时(0 时刻) 优先级都为0。每经过1 个时间单位，如果外卖店没有订单，则优先级会减少1，最低减到0；而如果外卖店有订单，则优先级不减反加，每有一单优先级加2。如果某家外卖店某时刻优先级大于5，则会被系统加入优先缓存中；如果优先级小于等于3，则会被清除出优先缓存。给定T 时刻以内的M 条订单信息，请你计算T 时刻时有多少外卖店在优先缓存中。输入：第一行包含3 个整数N、M 和T。以下M 行每行包含两个整数ts 和id，表示ts 时刻编号id 的外卖店收到一个订单1&lt;=N, M, T&lt;=100000，1&lt;=ts&lt;=T，1&lt;=id&lt;=N。输出：输出一个整数代表答案。</code></pre><h1 id="2、JAVA代码"><a href="#2、JAVA代码" class="headerlink" title="2、JAVA代码"></a>2、JAVA代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n, m, t;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Integer, ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> result;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        m = in.nextInt();</span><br><span class="line">        t = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(id)) &#123;</span><br><span class="line">                map.get(id).add(time);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">                temp.add(time);</span><br><span class="line">                map.put(id, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        ArrayList&lt;Map.Entry&lt;Integer, ArrayList&lt;Integer&gt;&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;Integer, ArrayList&lt;Integer&gt;&gt;&gt;(</span><br><span class="line">                map.entrySet());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); ++i) &#123;</span><br><span class="line">            Entry&lt;Integer, ArrayList&lt;Integer&gt;&gt; entry = list.get(i);</span><br><span class="line">            ArrayList&lt;Integer&gt; list2 = entry.getValue();</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[t + <span class="number">2</span>];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; list2.size(); ++j)</span><br><span class="line">                count[list2.get(j)]++;</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= t; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">                        num--;</span><br><span class="line">                    <span class="keyword">if</span> (num &lt;= <span class="number">3</span>)</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    num += count[j] * <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (num &gt; <span class="number">5</span>)</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                result++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯_JAVA组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 蓝桥杯真题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯简介</title>
      <link href="/2025/01/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%80%E4%BB%8B/"/>
      <url>/2025/01/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-学习计划"><a href="#1-学习计划" class="headerlink" title="1.学习计划"></a>1.学习计划</h1><p>第 1周 蓝桥杯软件赛介绍+官方链接+零基础能得奖吗？<br>第 2周: 常考知识点+蓝桥杯怎么判题+备赛计划<br>第 3周: 填空题（分数少但越来越不好做）<br>第 4周: （练习再多也不够的）杂题1<br>第 5周: 杂题2<br>第 6周: （基本数据结构）数组+队列<br>第 7周: 栈+二叉树<br>第 8周: 排序函数+排列和组合（必考!）<br>第 9周: 前缀和（简单好用）<br>第10周: 二分（可难可易）<br>第11周: 贪心（并不简单）<br>第12周: DFS（必考!）<br>第13周: DFS（一定要）剪枝<br>第14周: BFS（常用于最短路）<br>第15周: 快速幂+素数<br>第16周: GCD+LCM<br>第17周: （高级数据结构）并查集（并不高级）<br>第18周: 动态规划DP（真烧脑但是必考）<br>第19周: （常见图论问题）最短路<br>第20周: 最后谈谈还有哪些知识点可能考</p><h2 id="2蓝桥杯软件赛介绍"><a href="#2蓝桥杯软件赛介绍" class="headerlink" title="2蓝桥杯软件赛介绍"></a>2蓝桥杯软件赛介绍</h2><h3 id="2-1有必要参加蓝桥杯吗？"><a href="#2-1有必要参加蓝桥杯吗？" class="headerlink" title="2.1有必要参加蓝桥杯吗？"></a>2.1有必要参加蓝桥杯吗？</h3><p>有必要！蓝桥杯已经成了IT专业人才的钢印。<br>首先，谁在参赛？<br>最近的2023年第14届蓝桥杯，有1600所高校参加，17万大学生参赛。（中国共有2800所高校，IT方向的学生每届约100万。）<br>很多大学每年有数百人参赛。例如我在的华东理工大学，2023年第14届蓝桥杯有600学生参加。有的学校有上千人参赛。将来准备做码农的，差不多都参加过蓝桥杯。<br>其次，蓝桥杯有用吗？<br>这需要提到码农的核心能力了。我认为是这几点：代码能力、思维和逻辑、算法知识、自主学习能力。这些正是蓝桥杯考核的能力。<br>不参加蓝桥杯，一名未来码农的职业生涯是不完美的。<br>我们这个专题主要学习的是Java的C组</p><h3 id="2-2蓝桥杯软件赛的题型"><a href="#2-2蓝桥杯软件赛的题型" class="headerlink" title="2.2蓝桥杯软件赛的题型"></a>2.2蓝桥杯软件赛的题型</h3><p>时间4小时，共10题，有两种题型，都是客观题，由机器判题，绝对公平。总分150.</p><h4 id="1-填空题"><a href="#1-填空题" class="headerlink" title="1.填空题"></a>1.填空题</h4><p>  共2题，每题5分。不要求解题过程，不限制解题手段（可以使用任何开发语言或工具，甚至是手算），只要求填写最终的结果。<br>难度：一般比较简单，有时很难。<br>例子：</p><ul><li>简单的填空题：<a href="../%E8%93%9D%E6%A1%A5%E6%9D%AF2019%E7%9C%81%E8%B5%9BA%E7%BB%84%E7%AC%AC1%E9%A2%98/">2019省赛A组第1题</a></li><li>极难的填空题：<a href="../%E8%93%9D%E6%A1%A5%E6%9D%AF2017%E7%9C%81%E8%B5%9BA%E7%BB%84%E7%AC%AC3%E9%A2%98/">2017省赛A组第3题</a></li></ul><h4 id="2-编程题"><a href="#2-编程题" class="headerlink" title="2. 编程题"></a>2. 编程题</h4><p>  共8题，分值：10、10、15、15、20、20、25、25。<br>  例子：<br>  不用算法，但比较难：<a href="../%E8%93%9D%E6%A1%A5%E6%9D%AF2019%E7%9C%81%E8%B5%9BA%E7%BB%84%E7%AC%AC7%E9%A2%98/">2019省赛A组第7题</a><br>  需要学算法，但不难：<a href="../%E8%93%9D%E6%A1%A5%E6%9D%AF2019%E7%9C%81%E8%B5%9BA%E7%BB%84%E7%AC%AC8%E9%A2%98/">2019省赛A组第8题</a></p><h3 id="蓝桥杯的好处"><a href="#蓝桥杯的好处" class="headerlink" title="蓝桥杯的好处"></a>蓝桥杯的好处</h3><h4 id="1-可以丰富自己的大学经历"><a href="#1-可以丰富自己的大学经历" class="headerlink" title="1. 可以丰富自己的大学经历"></a>1. 可以丰富自己的大学经历</h4><p>有的人，在大学失去了方向和斗志，浑浑噩噩，当初信誓旦旦要从事IT相关领域，最后发现，是从事打游戏这个领域，毕业前才发现，自己所学甚少。 而蓝桥杯大赛，恰好可以让你丰富自己的大学经历，不枉费专业，不虚此行。</p><h4 id="2-可以提供自己的实力和水平"><a href="#2-可以提供自己的实力和水平" class="headerlink" title="2. 可以提供自己的实力和水平"></a>2. 可以提供自己的实力和水平</h4><p>有不少同学是很有上进心的，但苦于不知道怎么发力。那么，蓝桥杯大赛，能给你指引好方向，让你处在竞争的氛围中，牵引着你向前。通过大赛实战，不断地检验和完善自己，经历挫败和曲折后，获得成功，这种经历，尤为珍贵。</p><h4 id="3-可以为将来的职业铺好道路"><a href="#3-可以为将来的职业铺好道路" class="headerlink" title="3. 可以为将来的职业铺好道路"></a>3. 可以为将来的职业铺好道路</h4><p>大家都是要去求职的，在面试中，最忌讳的就是，拿不出曾经的经历和成绩，无法打动面试官和公司。有的人在面试时，只说自己爱好学习，但拿不出任何证据。相反，如果参加蓝桥杯这样的大赛，成功也好，失败也好，至少来讲，你比别人多了一块敲门砖，面试官也会对你刮目相看。</p><h2 id="蓝桥杯比赛形式"><a href="#蓝桥杯比赛形式" class="headerlink" title="蓝桥杯比赛形式"></a>蓝桥杯比赛形式</h2><table><thead><tr><th>队伍形式</th><th>个人赛</th></tr></thead><tbody><tr><td>赛制形式</td><td>OI</td></tr><tr><td>分组形式</td><td>研究生组、A组、B组、C组</td></tr><tr><td>比赛时长</td><td>4小时</td></tr><tr><td>题目类型</td><td>填空+编程题</td></tr><tr><td>官网地址</td><td>dasai.lanqiao.cn</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯_JAVA组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎页面</title>
      <link href="/2025/01/01/%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6/"/>
      <url>/2025/01/01/%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎来到我的网站！"><a href="#欢迎来到我的网站！" class="headerlink" title="欢迎来到我的网站！"></a>欢迎来到我的网站！</h1><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>温馨之家，一个充满温情与精致的线上港湾。在这里，我们以专业的眼光和匠心独运的设计，为您精心打造了一个舒适而高端的网络空间。无论是信息的呈现、功能的布局，还是服务的细节，我们力求尽善尽美，只为让您在繁忙的生活中找到一片宁静与归属。我们相信，温馨之家不仅是一个网站，更是您心灵休憩的高级居所，一个让您感受到家的温暖与高级享受的完美之地。在这里，您可以尽情放松身心，享受专属的高品质体验，仿佛置身于一个精心布置的高级家园，感受那份无与伦比的舒适与优雅</p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a>联系我们</h2><p>如果你有任何问题或需要进一步的帮助，请通过以下方式联系我们：</p><ul><li><strong>邮箱</strong>：<a href="mailto:&#47;&#47;&#x32;&#x37;&#51;&#51;&#54;&#56;&#51;&#x31;&#49;&#54;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;">2733683116@qq.com</a></li><li><strong>电话</strong>：<a href="tel://13736821326">13736821326</a></li></ul><h2 id="社交媒体"><a href="#社交媒体" class="headerlink" title="社交媒体"></a>社交媒体</h2><p>关注我们的社交媒体账号，获取最新资讯和动态：</p><ul><li><a href="https://www.github.com/HuCiZhi">github</a></li><li><a href="https://v.douyin.com/iymHFGq9/%205@1.com%20:7pm">douyin</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 欢迎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欢迎 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
